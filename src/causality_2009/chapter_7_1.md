# Chapter 7.1 结构模型语义学

## 7.1.1 定义：因果模型、行动与反事实
```admonish check
### <a id="def7.1.1">定义7.1.1 (因果模型)</a>
&emsp;&emsp;因果模型是一个三元模型
\\[M = <U , V , F>\\]
其中：  
&emsp;&emsp;(Ⅰ) *U* 是一组背景变量集，由模型外部因素决定。  
&emsp;&emsp;(Ⅱ) *V* 是由变量 \\({V_1, V_2,..., V_n}\\) 组成的集合，称为内生变量，这些变量由模型中的变量(即\\( U \cup V \\)) 决定。 
&emsp;&emsp;(Ⅲ)  *F* 是由 \\({f_1, f_2,..., f_m}\\) 组成的函数集，每个 \\(f_i\\) 都是从 \\(U_i \cup PA_i\\) 到 \\(V_i\\) 的映射，其中 \\( U_i \subset U\\)， \\( PA_i \subset V \diagdown V_i\\)，并且全集 *F* 形成从 *U* 到 *V* 的映射。换句话说，每个函数为内生变量 \\(V_i\\) 指定了一个值，该值取决于 \\( V \cup V \\)中选择的变量子集(的值)，并且全集 *F* 具有唯一的解 \\(V(u)\\)。  
```

&emsp;&emsp;每个因果模型 *M* 与有向图 *G(M)* 相关联，其中每个节点对应一个变量，有向边是从 \\( PA_i 和 U_i 中的节点指向 V_i\\)。我们称 *G(M)* 为因果模型 *M* 的因果图。因果图 *G(M)* 仅识别对每个节点 \\(V_i\\) 来说有直接影响的内生变量和外部变量。 *G(M)* 未指定 \\(f_i\\) 的具体函数形式。 将节点 *V* 的父节点限制为 \\(PA_i\\) 的主要原因是： *V* 的子集这一惯例源于这样一个事实 —— 外部变量通常是不可观测的(因而赋予信念)。然而，一般情况下，我们依然可以扩展父节点集合来包含集合 *U* 中的可观测的变量。

```admonish check
### <a id="def7.1.2">定义7.1.2 (子模型)</a>
&emsp;&emsp;令 *M* 为一个因果模型，*X* 为 *V* 中的一组变量集合， x 是 *X* 的一个具体赋值。 *M* 的子模型 *M<sub>x</sub>* 为：
\\[M_x = < U , V , F_x >\\]
它是一个因果模型，其中 *F<sub>x</sub>* 是通过删除 *F* 中与集合 *X* 的变量相应的所有函数 *f<sub>i</sub>* ，并将其替换为常数函数 \\( X = x\\) 的集合而组成的。
```

&emsp;&emsp;子模型(sub model)用于表示局部行动和假设变化的效应，包括哪些由反事实的前提所隐含的效应。从 *M* 到 *M<sub>x</sub>* 的转换修改了 *F* 的代数表示，两者的区别仅在与 *M<sub>x</sub>* 直接确定了指向 *X* 的机制 *(f)*。

```admonish check
### <a id="def7.1.3">定义7.1.3 (行为效应)</a>
&emsp;&emsp;令 *M* 为一个因果模型，*X* 为 *V* 中的一组变量集合， *x* 是 *X* 的一个具体赋值。 子模型 *M<sub>x</sub>* 定义了行动 *do(X=x)* 对 *M* 的效应。
```

```admonish check
### <a id="def7.1.4">定义7.1.4 (潜在响应)</a>、
&emsp;&emsp;令 *X* 和 *Y* 为 *V* 的任意两个变量子集。*Y* 对行动 *do(X=x)* 的潜在响应表示为 *Y_x(u)* ，是方程组 \\(F_x 中 Y 的解， 即 Y_x(u) = Y_{M_x}(u)\\)
```

```admonish check
### <a id="def7.1.5">定义7.1.5 (反事实)</a>
&emsp;&emsp;令 *X* 和 *Y* 为 *V* 的任意两个变量子集，反事实语句"在条件 *u* 下，如果 *X* 为 *x* ，则 *Y* 为 *y* "， 记作 \\( Y_x(u) = y\\) ，其中 \\(Y_x(u) 为 Y 对 X=x\\) 的潜在响应。
```

&emsp;&emsp;因此，定义7.1.5将反事实语句"如若 *X* 为 *x*" 解释为对模型中方程的假设性修改，它模拟了一种外部行动(或自发变化)，这种行动改变了原有的实际过程，并以最小的机制变化强制执行条件 "*X* = *x*"。这是反事实语义学中的关键，因为它允许 *x* 与 *X(u)* 的值不同，而不会造成逻辑上的矛盾。

&emsp;&emsp;**我们感兴趣的是，根据实际观测到的变量来计算反事实的概率。**

## 7.1.4 孪生网络法
&emsp;&emsp;像连体双胞胎(Siamese twins)一样，这两个网络共享背景变量(在我们的例子中为 *U* 和 *W*)，因为他们在修改后保持不变。内生变量被复制并被明确标记，因为它们在假设世界和真实世界中可能会得出不同的值。因此，在模型\\(\<M_{\neg A} , P(u,v|z) \> \\)中计算\\(P(\neg  D)\\)的任务就简化为在孪生网络中计算\\(P(\neg D^{\ast}|D)\\)的任务，其中\\(A^{\ast}\\)是假设世界的变量被赋值为假。  
  
&emsp;&emsp;孪生网络表示法还提供了一种检验反事实变量之间独立性的有效方法。而且在孪生网络中直观看出的结论很难从链式模型本身或从该模型方程中得出。